using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace Jiper.FontAwesome.IconExtractor;

internal static class Program
{
    private static int Main(string[] args)
    {
        try
        {
            var outputPath = args.Length > 0 && !string.IsNullOrWhiteSpace(args[0])
                ? Path.GetFullPath(args[0])
                : Path.Combine(Environment.CurrentDirectory, "../../../../Jiper.FontAwesome.Blazor/Components", "FaIconsFree.cs");

            var targetNamespace = args.Length > 1 && !string.IsNullOrWhiteSpace(args[1])
                ? args[1]
                : "Jiper.FontAwesome.Blazor.Components";

            var className = args.Length > 2 && !string.IsNullOrWhiteSpace(args[2])
                ? args[2]
                : "FaIconsFree";

            EnsureGitAvailable();

            var tempDir = Path.Combine(Path.GetTempPath(), "fa-repo-" + Guid.NewGuid().ToString("N"));
            Directory.CreateDirectory(tempDir);

            try
            {
                Console.WriteLine("Cloning Font Awesome repository...");
                RunProcess("git", $"clone --depth 1 https://github.com/FortAwesome/Font-Awesome.git \"{tempDir}\"");

                var dtsPath = Path.Combine(tempDir, "js-packages", "@fortawesome", "fontawesome-common-types", "index.d.ts");
                if (!File.Exists(dtsPath))
                {
                    throw new FileNotFoundException("Could not find index.d.ts in cloned repository.", dtsPath);
                }

                var content = File.ReadAllText(dtsPath);

                // Extract the IconName union type block
                var match = Regex.Match(content, @"export\s+type\s+IconName\s*=\s*(?<body>[\s\S]*?);", RegexOptions.Multiline);
                if (!match.Success)
                {
                    throw new InvalidOperationException("Could not locate `export type IconName = ...;` block in index.d.ts.");
                }

                var body = match.Groups["body"].Value;
                var iconMatches = Regex.Matches(body, @"'([^']+)'");
                var iconNames = iconMatches.Cast<Match>().Select(m => m.Groups[1].Value).ToList();

                if (iconNames.Count == 0)
                {
                    throw new InvalidOperationException("No IconName entries found in IconName union type.");
                }

                Console.WriteLine($"Found {iconNames.Count} icon names. Generating constants...");

                var generated = GenerateClass(targetNamespace, className, iconNames);
                var outputDir = Path.GetDirectoryName(outputPath) ?? Environment.CurrentDirectory;
                Directory.CreateDirectory(outputDir);
                File.WriteAllText(outputPath, generated, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));

                Console.WriteLine($"Generated {iconNames.Count} constants into: {outputPath}");
                return 0;
            }
            finally
            {
                // Clean up the cloned repository
                TryDeleteDirectory(tempDir);
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("Error: " + ex.Message);
            Console.Error.WriteLine(ex.ToString());
            return 1;
        }
    }

    private static string GenerateClass(string namespaceName, string className, IList<string> kebabNames)
    {
        var usedIdentifiers = new HashSet<string>(StringComparer.Ordinal);
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file was generated by Jiper.FontAwesome.IconExtractor");
        sb.AppendLine("// Source: https://github.com/FortAwesome/Font-Awesome");
        sb.AppendLine($"// Generated at: {DateTimeOffset.Now:O}");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public static class {SanitizeTypeName(className)}");
        sb.AppendLine("{");

        foreach (var kebab in kebabNames)
        {
            var identifier = ToPascalCaseIdentifier(kebab);

            // Ensure uniqueness
            var baseId = identifier;
            var suffix = 1;
            while (!usedIdentifiers.Add(identifier))
            {
                identifier = $"{baseId}_{suffix++}";
            }

            sb.Append("    public const string ").Append(identifier).Append(" = ").Append('"').Append(kebab).AppendLine("\";");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string ToPascalCaseIdentifier(string kebab)
    {
        if (string.IsNullOrWhiteSpace(kebab))
            return "_";

        string id;

        // If the input is a single alphanumeric token (no separators) and appears to be
        // camelCase/PascalCase already, preserve its internal casing and just ensure
        // the first character is uppercase (when it's a letter).
        if (Regex.IsMatch(kebab, @"^[A-Za-z0-9]+$") && (char.IsUpper(kebab[0]) || kebab.Skip(1).Any(char.IsUpper)))
        {
            id = char.IsLetter(kebab[0])
                ? char.ToUpper(kebab[0], CultureInfo.InvariantCulture) + kebab.Substring(1)
                : kebab;
        }
        else
        {
            // Split on non-alphanumeric characters
            var parts = Regex.Split(kebab, "[^A-Za-z0-9]+")
                             .Where(p => p.Length > 0)
                             .ToArray();

            // PascalCase each part
            var sb = new StringBuilder();
            foreach (var p in parts)
            {
                if (p.Length == 0) continue;

                // If the part is all digits, keep as is
                if (p.All(char.IsDigit))
                {
                    sb.Append(p);
                    continue;
                }

                // Title case: first letter upper, rest lower (preserve digits)
                var first = p[0];
                var rest = p.Length > 1 ? p.Substring(1) : string.Empty;

                sb.Append(char.ToUpper(first, CultureInfo.InvariantCulture));
                sb.Append(rest.ToLower(CultureInfo.InvariantCulture));
            }

            id = sb.Length > 0 ? sb.ToString() : "_";
        }

        // If starts with a digit, prefix underscore
        if (char.IsDigit(id[0]))
            id = "_" + id;

        // If identifier becomes empty or invalid start char, fix
        if (!IsValidIdentifierStart(id[0]))
            id = "_" + id;

        // Replace any remaining invalid characters (shouldn't be any after split), but just in case
        var cleaned = new StringBuilder(id.Length);
        foreach (var ch in id)
        {
            cleaned.Append(IsValidIdentifierPart(ch) ? ch : '_');
        }
        id = cleaned.ToString();

        // Escape C# keywords
        if (CSharpKeywords.Contains(id))
            id = "@" + id;

        // Avoid conflicts with System.Object member names (e.g., Equals, ToString, GetHashCode, GetType, ...)
        if (ObjectMemberNames.Contains(id))
            id = id + "_";

        return id;
    }

    private static string SanitizeTypeName(string name)
    {
        // Ensure a safe type name
        if (string.IsNullOrWhiteSpace(name)) return "FaIconsFree";
        var id = ToPascalCaseIdentifier(name);
        // Remove leading @ if any (not valid for type names)
        if (id.StartsWith("@", StringComparison.Ordinal)) id = id.Substring(1);
        return id;
    }

    private static bool IsValidIdentifierStart(char ch) =>
        ch == '_' || char.IsLetter(ch);

    private static bool IsValidIdentifierPart(char ch) =>
        ch == '_' || char.IsLetterOrDigit(ch);

    private static readonly HashSet<string> CSharpKeywords = new(StringComparer.Ordinal)
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class",
        "const","continue","decimal","default","delegate","do","double","else","enum","event",
        "explicit","extern","false","finally","fixed","float","for","foreach","goto","if",
        "implicit","in","int","interface","internal","is","lock","long","namespace","new",
        "null","object","operator","out","override","params","private","protected","public",
        "readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static",
        "string","struct","switch","this","throw","true","try","typeof","uint","ulong",
        "unchecked","unsafe","ushort","using","virtual","void","volatile","while",
        // contextual keywords
        "add","and","alias","ascending","async","await","by","descending","dynamic","equals",
        "file","from","get","global","group","init","into","join","let","managed","nameof",
        "nint","not","notnull","nuint","on","or","orderby","partial","record","remove","required",
        "scoped","select","set","unmanaged","value","var","when","where","with","yield"
    };

    // Names of System.Object members to avoid hiding with generated constants.
    private static readonly HashSet<string> ObjectMemberNames = new(StringComparer.Ordinal)
    {
        "Equals",
        "GetHashCode",
        "ToString",
        "GetType",
        "Finalize",
        "MemberwiseClone",
        "ReferenceEquals"
    };

    private static void EnsureGitAvailable()
    {
        try
        {
            RunProcess("git", "--version");
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("Git is required but was not found on PATH. Please install Git and try again.", ex);
        }
    }

    private static void RunProcess(string fileName, string arguments)
    {
        using var proc = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = fileName,
                Arguments = arguments,
                CreateNoWindow = true,
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            }
        };

        proc.Start();
        var stdout = proc.StandardOutput.ReadToEnd();
        var stderr = proc.StandardError.ReadToEnd();
        proc.WaitForExit();

        if (proc.ExitCode != 0)
        {
            throw new InvalidOperationException(
                $"Process `{fileName} {arguments}` failed with code {proc.ExitCode}.{Environment.NewLine}" +
                $"STDOUT: {stdout}{Environment.NewLine}STDERR: {stderr}");
        }
    }

    private static void TryDeleteDirectory(string path)
    {
        if (string.IsNullOrWhiteSpace(path) || !Directory.Exists(path)) return;
        try
        {
            // Make files writable and delete
            foreach (var file in Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories))
            {
                try
                {
                    var attr = File.GetAttributes(file);
                    if ((attr & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
                        File.SetAttributes(file, attr & ~FileAttributes.ReadOnly);
                }
                catch
                {
                    // ignore
                }
            }
            Directory.Delete(path, recursive: true);
        }
        catch
        {
            // ignore cleanup errors
        }
    }
}
